First-order tableau with unification[edit]
The main problem of tableau without unification is how to choose a ground term t for the universal quantifier rule. Indeed, every possible ground term can be used, but clearly most of them might be useless for closing the tableau.
A solution to this problem is to "delay" the choice of the term to the time when the consequent of the rule allows closing at least a branch of the tableau. This can be done by using a variable instead of a term, so that \forall x . \gamma(x) generates \gamma(x'), and then allowing substitutions to later replace x' with a term. The rule for universal quantifiers becomes:
(\forall) \frac{\forall x . \gamma(x)}{\gamma(x')} where x' is a variable not occurring everywhere else in the tableau
While the initial set of formulae is supposed not to contain free variables, a formula of the tableau contain the free variables generated by this rule. These free variables are implicitly considered universally quantified.
This rule employs a variable instead of a ground term. The gain of this change is that these variables can be then given a value when a branch of the tableau can be closed, solving the problem of generating terms that might be useless.
(\sigma)	if \sigma is the most general unifier of two literals A and B, where A and the negation of B occur in the same branch of the tableau, \sigma can be applied at the same time to all formulae of the tableau
As an example, \{\neg P(a), \forall x . P(x)\} can be proved unsatisfiable by first generating P(x_1); the negation of this literal is unifiable with \neg P(a), the most general unifier being the substitution that replaces x_1 with a; applying this substitution results in replacing P(x_1) with P(a), which closes the tableau.
This rule closes at least a branch of the tableau -the one containing the considered pair of literals. However, the substitution has to be applied to the whole tableau, not only on these two literals. This is expressed by saying that the free variables of the tableau are rigid: if an occurrence of a variable is replaced by something else, all other occurrences of the same variable must be replaced in the same way. Formally, the free variables are (implicitly) universally quantified and all formulae of the tableau are within the scope of these quantifiers.
Existential quantifiers are dealt with by Skolemization. Contrary to the tableau without unification, Skolem terms may not be simple constant. Indeed, formulae in a tableau with unification may contain free variables, which are implicitly considered universally quantified. As a result, a formula like \exists x . \delta(x) may be within the scope of universal quantifiers; if this is the case, the Skolem term is not a simple constant but a term made of a new function symbol and the free variables of the formula.
(\exists) \frac{\exists x . \delta(x)}{\delta(f(x_1,\ldots,x_n))} where f is a new function symbol and x_1,\ldots,x_n the free variables of \delta

A first-order tableau with unification for {∀x.P(x), ∃x.(¬P(x)⋁¬P(f(x)))}. For clarity, formulae are numbered on the left and the formula and rule used at each step is on the right
This rule incorporates a simplification over a rule where x_1,\ldots,x_n are the free variables of the branch, not of \delta alone. This rule can be further simplified by the reuse of a function symbol if it has already been used in a formula that is identical to \delta up to variable renaming.
The formula represented by a tableau is obtained in a way that is similar to the propositional case, with the additional assumption that free variables are considered universally quantified. As for the propositional case, formulae in each branch are conjoined and the resulting formulae are disjoined. In addition, all free variables of the resulting formula are universally quantified. All these quantifiers have the whole formula in their scope. In other words, if F is the formula obtained by disjoining the conjunction of the formulae in each branch, and x_1,\ldots,x_n are the free variables in it, then \forall x_1,\ldots,x_n . F is the formula represented by the tableau. The following considerations apply:
The assumption that free variables are universally quantified is what makes the application of a most general unifier a sound rule: since \gamma(x') means that \gamma is true for every possible value of x', then \gamma(t) is true for the term t that the most general unifier replaces x with.
Free variables in a tableau are rigid: all occurrences of the same variable have to be replaced all with the same term. Every variable can be considered a symbol representing a term that is yet to be decided. This is a consequence of free variables being assumed universally quantified over the whole formula represented by the tableau: if the same variable occurs free in two different nodes, both occurrences are in the scope of the same quantifier. As an example, if the formulae in two nodes are A(x) and B(x), where x is free in both, the formula represented by the tableau is something in the form \forall x . (...A(x)...B(x)...). This formula implies that (...A(x)...B(x)...) is true for any value of x, but does not in general imply (...A(t)...A(t')...) for two different terms t and t', as these two terms may in general take different values. This means that x cannot be replaced by two different terms in A(x) and B(x).
Free variables in a formula to check for validity are also considered universally quantified. However, these variables cannot be left free when building a tableau, because tableau rules works on the converse of the formula but still treats free variables as universally quantified. For example, P(x) \rightarrow P(c) is not valid (it is not true in the model where D=\{1,2\}, P(1)=\bot, P(2)=\top, c=1, and the interpretation where x=2). Consequently, \{P(x),\neg P(c)\} is satisfiable (it is satisfied by the same model and interpretation). However, a closed tableau could be generated with P(x) and \neg P(c), and substituting x with c would generate a closure. A correct procedure is to first make universal quantifiers explicit, thus generating \forall x . (P(x) \rightarrow P(c)).
The following two variants are also correct.
Applying to the whole tableau a substitution to the free variables of the tableau is a correct rule, provided that this substitution is free for the formula representing the tableau. In other worlds, applying such a substitution leads to a tableau whose formula is still a consequence of the input set. Using most general unifiers automatically ensures that the condition of freeness for the tableau is met.
While in general every variable has to be replaced with the same term in the whole tableau, there are some special cases in which this is not necessary.
Tableaux with unification can be proved complete: if a set of formulae is unsatisfiable, it has a tableau-with-unification proof. However, actually finding such a proof may be a difficult problem. Contrarily to the case without unification, applying a substitution can modify the existing part of a tableau; while applying a substitution closes at least a branch, it may make other branches impossible to close (even if the set is unsatisfiable).
A solution to this problem is that delayed instantiation: no substitution is applied until one that closes all branches at the same time is found. With this variant, a proof for an unsatisfiable set can always be found by a suitable policy of application of the other rules. This method however requires the whole tableau to be kept in memory: the general method closes branches which can be then discarded, while this variant does not close any branch until the end.
The problem that some tableaux that can be generated are impossible to close even if the set is unsatisfiable is common to other sets of tableau expansion rules: even if some specific sequences of application of these rules allow constructing a closed tableau (if the set is unsatisfiable), some other sequences lead to tableaux that cannot be closed. General solutions for these cases are outlined in the "Searching for a tableau" section.
