For Description Logics (DLs) having no inverse roles, the global (sub-)tableaux caching functionality is known to be an effective runtime optimization and was built into some highly-optimized tableau-based DL systems, e.g., FaCT [Hor98], DLP [Pet98], and RACER [HM01b]. Roughly speaking, tableaux caching is a looking-up mechanism consisting of consistency caching and inconsistency caching. The use of cached results can effectively avoid repeated searches by a fast retrieval of previously stored information about a label and its satisfiability status. However, for DLs with inverse roles, the soundness of tableaux caching is problematic [BCM+03] because conventionally tableaux caching mechanisms do not take backward-propagation of constraints into consideration1. It is evident that the above mentioned DL systems and their successors when reasoning for DLs with inverse roles do not use the full-fledged tableaux caching functionality previously implemented for DLs without inverse roles. 
There is another approach to DLs with inverse roles [TH06, SPG+07]. By contrast
to the global tableaux caching, this approach uses some optimizations (e.g., dynamic blocking and pseudo model merging [THPS07]) that adapt and scale better to Dls with inverse roles. For example, FaCT++ [TH06] implemented a “ToDo List” architecture and is able to schedule propagation of constraints [THPS07]. This approach is influential and is a prominent feature of some new DL systems. It can be understood that managing constraint propagation in the presence of inverse roles is an important issue for tableaux systems.
A sound and restricted global tableaux caching was reported in [DH05]; the idea is to compute labels potentially unsafe for reuse and then exclude them from caching. An experimental system has been implemented as a hybrid of an ALC-style (restricted) tableaux caching functionality with a standard ALCI-style tableaux system. But the preliminary results were mixed [DH06]. Therefore, this chapter continues on developing a new way that can fully utilize the power of caching (available for Dls without inverse roles) rather than being restrictive as in [DH05] (see also Chapter 2).
1Though it is possible to do so, the implementation would be complicated and the run-time penalty might be high. ∃R−.(∀R.⊥) is not consistent though its sub-concept ∀R.⊥ is; an overlooking of backward propagation of constraints (⊥ here) leads to unsoundness. A second source of unsoundness as was pointed out in [HM00a] is an inadvertent use of caching for Abox individual.
The two sources of unsoundness might occur in ALCI Abox problems.
4.1.2 Why Inverse Relation Is The Problem
Here, let us take an inside look at some common issues from tableau-based systems for DLs, and see the difference between an ALC system and an ALCI system. Recall that to restore the tableaux structure (a.k.a. completion graph) to a previous state during a backtracking phase, it is necessary to make a copy of (portions of) the tableaux structure for each sequence of deterministic operations. In ALC the scope of the undoing area (i.e. the portion of changes to be reverted) is bounded below a subtree rooted at the source of a conflict; in ALCI the scope of undoing is hard to calculate even when sources of conflicts can be optimally located. Moreover, it is more difficult to efficiently propagate inconsistency results in ALCI, which also means that the inconsistency caching functionality is weaker in ALCI. The left graph below shows an inconsistent structure where no nontrivial inconsistency is inferred.
Figure 4.1: Inconsistency Propagation and Backward Constraint Propagation
In an ALC tableaux structure, a node does not propagate constraints to its predecessor, and its sibling nodes can be handled independently; this is not true in ALCI.
It is the issue of backward propagation of constraints that makes an ALCI tableaux system behave differently from ALC’s. The two rightmost pictures above show that backward propagation of constraints can be circumvented by way of enforcing some general concept inclusions2 (a variant of the technique presented in Chapter 3).
ALCFI has been well studied in the literature [CGR98, HS99, Tob00, Lut04]. It
extends the basic DL ALC with inverse roles and functional restrictions. A functional restriction is of the form (≤1 R) which restricts the number of R-neighbors to be at most one, and can be viewed as a partial function over the interpretation domain [Lut99]. When considering general concept inclusions, this logic still has the tree model property but no finite model property. For example, it is only possible with an infinite model to satisfy the concept ¬A and a general concept inclusion  # (≤1 R−) # ∃R.A.
To avoid incorrect infinite models, the dynamic pair-wise blocking technique [HS99] is used to guarantee soundness.
Figure 4.2: A Model for ¬A w.r.t. T = { # (≤1 R−), #∃R.A}
It is appropriate in this context to discuss blocking techniques, which are also known as cycle detection and termination mechanisms. Generally speaking, a node x is blocked if none of its ancestors are blocked, and x has a witness x# (one of x’s ancestor nodes) such that the labels of x and x# meet certain prior conditions. For example in the equality blocking technique, if L(x) = L(x#
) (note that L(.) is a set of concept expressions denoting a label for a tableau node), then it is said that x is blocked by 2When the predecessor node does not get backward propagated constraints, a primitive clash like {A, ¬A} will be triggered at the successor node (when the recorded axioms are enforced at the
predecessor node). This is called “backward propagation don’t-care”, see Figure 4.1 and Lemma 12.
49
x#
. Provably tableau-based decision procedures can safely ignore any blocked node
without compromising soundness. It was shown in [HS99] that, even for ALCI, static blocking is inadequate and unsound. Therefore it is necessary to use dynamic blocking for DLs with inverse roles. If the original conditions have been changed (due to backward constraint propagation), it is necessary to break the established blockings to reflect the changes3. Also presented in [HS99] is a dynamic pair-wise blocking technique (and its optimized variants) designed for searching infinite models. The dynamic pair-wise blocking is also known as “double blocking” because the blocking condition is specified in patterns of depth 2 [BHLW03, HM04, Hla04], i.e., the matching is specified by the relation of two pairs of predecessor-successor nodes (for an illustration and explanation please see “double blocking” in Section 6.4.3 of Chapter 6).
It is known that the global caching of both consistency and inconsistency label sets is sufficient to get an ExpTime tableau-based decision procedure [DM00], however, no example has been set up for DLs with inverse roles so far4. We will show a worst-case exponential time decision procedure for ALCFI.
Let us connect two related notions, namely, the blocking technique and the global tableaux caching (in the context of DLs having no inverse roles). This connection is plausible because the primary purpose of both is to ensure the termination of tableau-based decision procedures. These two notions, usually discussed in a tree or forest structure5, differ in their applicable scope: blocking is applicable only between 3A broken blocking might later be re-established again [HS99].
4It was recently shown in [GN07] and [DH07a] that ExpTime tableau-based decision procedures were proposed for DLs with inverse roles.
5And also including a finite-sized non-tree structure in DLs containing ALCOIQ as a fragment.
a node and (one or many of) its ancestor nodes; caching is globally applicable as long as its application does not destroy soundness. The second difference is that caching is applicable to both satisfiable and unsatisfiable situations; but blocking is only applicable to satisfiable situations, which means blocking is not able to prune away “unpromising parts” of the search space.
