The Design of OWL 2 To address the problems with OWL 1 that we identified in Section 2, the design of OWL 2 has departed from that of OWL1 in several ways. 3.1. Increasing Language Expressivity The drawbacks of OWL 1 regarding expressivity identified in Section 2.1 have long been recognized in the DL community, and a significant amount of research has been devoted to finding possible solutions. The cumulative results of this work are embodied in the DL SROIQ [16], which is strictly more expressive than SHOIN . This is evidenced by an increase in the computational complexity of the basic reasoning problems: reasoning in SROIQ is 2NExpTime-complete [22], whereas in SHOIN it is NExpTime-complete [36]. Although reasoning in SROIQ is harder than in SHOIN , the tableaux-based reasoning algorithm for SROIQ [16] follows the same principles as the one for SHOIN . If the new features are not used, then the new reasoning algorithm behaves just like the old algorithm for SHOIN . Furthermore, the source of added complexity is well understood [22], and it seems realistic to expect that the complexity increase will not occur on typical practical problems. Finally, existing reasoners can and have been easily extended to SROIQ. Thus, SROIQ seems to provide a good logical underpinning for OWL 2 from both a theoretical and a practical perspective. 3.1.1. Qualified Number Restrictions Even while OWL 1 was being designed, it was known that QCRs could have been added to the language without any theoretical or practical problems: the resulting logics are still decidable and have been successfully implemented in practical reasoning systems. Moreover, as mentioned in Section 2.1.1, QCRs have been supported in DAML+OIL—a predecessor of OWL. Thus, qualified number restrictions are not really a novel feature of either 10 SROIQ or of DL-based ontology languages, and were incorporated into OWL 2 in the obvious way. 3.1.2. Relational Expressivity As mentioned in Section 2.1, a major drawback of OWL 1 is the limited expressivity regarding properties. This is addressed in SROIQ and OWL 2 by the addition of complex property inclusion axioms, which significantly increase the relational expressivity of the language. In particular, they provide for the propagation of one property along another. For example, axiom (22) states that, if a contains b and b has a part c, then a also contains c: SubPropertyOf( PropertyChain(contains hasPart) contains) (22) If such axioms are used in an unrestricted way, they easily make the logic undecidable. To achieve decidability, SROIQ (and hence OWL 2) imposes a regularity restriction on such axioms: roughly speaking, it must be possible to arrange all properties in a total ordering  such that, for each property p on the left-hand side of a subproperty axiom, p is either equal to or a -predecessor of the property on the right-hand side of the axiom. Although this might seem rather complex, it merely formalizes a simple restriction that complex subproperty axioms should not define properties in a cyclic way. For example, although (22) by itself does not cause problems, it should not be simultaneously used with the following axiom, which states that if b is a part of a and b contains c, then c is also a part of a: SubPropertyOf( PropertyChain(hasPart contains) hasPart) (23) The axioms (22) and (23) together introduce a cyclic dependency between contains and hasPart, which can easily lead to problems with decidability. In addition to complex property inclusion axioms, properties in SROIQ and OWL 2 can be transitive, reflexive, irreflexive, symmetric, and/or asymmetric, and pairs of properties can be made disjoint. Thus, OWL 2 provides many of the features necessary for applying the principles of mereology. 3.1.3. Increasing Datatype Expressivity OWL 2 significantly extends the set of built-in datatypes of OWL 1 by reusing certain datatypes from XML Schema. Thus, OWL 2 now supports owl:boolean, owl:string, xsd:integer , xsd:dateTime, xsd:hexBinary, and a number of datatypes derived from these by placing various restrictions on them. In addition, xsd:decimal, xsd:double, and xsd:float will most likely be complemented with owl:real—a datatype interpreted as the set of all real numbers. OWL 2 also provides a datatype restriction construct, which allows new datatypes to be defined by restricting the built-in datatypes in various ways. For example, the following expression defines a new datatype by specifying a lower bound of 18 on the XML Schema datatype xsd:integer : DatatypeRestriction(xsd:integer xsd:minInclusive 18) (24) It is worth mentioning, however, that the Working Group has still not made a final decision on the exact set of datatypes that the language will support. Therefore, some of the information in this section may become obsolete in the future. 3.1.4. Keys As mentioned in Section 2.1.4, keys are important in many applications. Extending DL-based languages such as OWL 2 with keys, however, poses both theoretical and practical problems [23]. Therefore, the Working Group has decided to include a more restricted variant of keys that can be useful in practice as well as relatively easy to implement, commonly known as easy keys. OWL 2 thus provides for key axioms of the form HasKey(CP1 . . . Pn), which state that the object or data properties Pi are keys for (named) instances of the class C—that is, no two (named) instances of C can coincide on the values of all Pi . For example, the following OWL 2 axiom states that persons are uniquely identified by their social security number: HasKey( Person hasSSN ) (25) The following assertions state that two individuals— PSmith and PeterSmith—have the same social security number: PropertyAssertion(PSmith hasSSN “123-45-6789”) (26) PropertyAssertion(PeterSmith hasSSN “123-45-6789”) (27) Since the individuals PSmith and PeterSmith are known by name, axioms (25)–(27) entail that PSmith and PeterSmith are the same individuals: SameIndividual(PSmith PeterSmith) (28) 11 Unlike the general keys, easy keys are not applied to individuals not known by name. For example, the following axiom states that Jane is connected through marriedTo to an individual α that is an instance of Man and that has “123-45-6789” as the value of hasSSN : ClassAssertion( SomeValuesFrom(marriedTo IntersectionOf( Man HasValue(hasSSN “123-45-6789”) ) ) Jane ) (29) Even though α has the same value for hasSSN as, say, PSmith, individual α is not known by name. Therefore, the key axiom (25) is not applicable to α so, consequently, axioms (25), (26), and (29) do not entail the following assertion: ClassAssertion(Man PSmith) (30) Thus, the main drawback of easy keys is that they can only produce consequences about explicit data and are thus relevant mainly for query answering, whereas the general variant of keys [23] can also affect the subsumption hierarchy between classes. The main benefits of easy keys are that adding them to OWL 2 do not increase the worst-case complexity of reasoning, and that implementing them in the existing reasoners is relatively straightforward. 3.1.5. Extensions under Discussion The Working Group is currently discussing whether to extend OWL 2 with n-ary datatypes, such as the binary datatype equal. Such datatypes could then be used to compare values of data properties for a given object. For example, the following expression defines the class of objects whose width is equal to their height: AllValuesFrom(width height equal) (31) Unfortunately, ever since concrete datatypes were introduced in [2], it has been known that comparing values of data properties for different objects (e.g., defining the class of people who have a child who is older than their spouse) easily leads to undecidability, unless the concept language is signifi- cantly weakened. Similarly, aggregate functions can be combined only with very simple DLs if decidability is desired [3], so it was therefore decided not to include these expressive features into OWL 2. 3.2. The MOF Metamodel for OWL 2 To solve the problems identified in Section 2.2, the structure of OWL 2 ontologies has been unambiguously specified using OMG’s Meta-Object Facility (MOF). 15 MOF is a well-known metalanguage, and has been extensively used for specification of other languages. The MOF metamodel—also called the structural specification—of OWL 2 is presented in the documents using the Unified Modeling Language (UML). The classes of the MOF metamodel describe the canonical structure of OWL 2 ontologies in a way that is independent of the syntax used to serialize the ontologies. The specification consists of 22 UML class diagrams. For example, Figure 1 shows the UML diagram that defines an ontology as consisting of a set of axioms and of a set of annotations; furthermore, it shows that an ontology can import a set of ontologies and that each axiom can contain a set of annotations. OWL 2 axioms are defined as subclasses of the abstract class Axiom. For example, Figure 2 shows the diagram that defines the structure of class axioms, where the axiom EquivalentClasses is defined as taking a set of classes. The MOF metamodel for OWL 2 can be seen as analogous to the Document Object Model (DOM) specification 16 for XML. It unambiguously specifies what OWL 2 ontologies are in terms of their structure and thus makes the specification precise. Moreover, it can be taken as a foundation for the design of an OWL 2 API. By committing to a well-known metamodel, APIs of different developers should be interoperable, which will reduce the burden on application developers. The MOF metamodel of OWL 2 also defines the notion of structural equivalence, which determines whether two ontology components are considered to be the same. For example, the following two OWL 2 axioms are not identical; they are, however, structurally equivalent, since the EquivalentClasses axiom consists of a set of classes in which the order of the elements is not relevant: EquivalentClasses(Person Human) (32) EquivalentClasses(Human Person) (33) Structural equivalence is important for the defi- nitions of the functionality of OWL 2 APIs and ser- 15 http://www.omg.org/mof/ 16 http://www.w3.org/DOM/ 12 Fig. 1. Object Model of OWL 2 Ontologies Fig. 2. Class Axioms in OWL 2 vices. For example, OWL 2 reasoners might support incremental addition and deletion of axioms. By relying on the notions of structural equivalence of axioms and sets of axioms, the semantics of the addition and deletion operations can be easily defined in terms of standard set operations on sets of axioms. 3.3. Typing and Declarations To address the problems described in Section 2.2.3 regarding disambiguation of ontology types, OWL 2 introduces the notion of declarations. All entities can, and sometimes even must, be declared in an OWL 2 ontology. A declaration for an entity with a URI u in an ontology O serves two purposes: – It states that u is part of the vocabulary of O; for example, an ontology editor can use declarations to implement functions such as “Add New Class.” – It associates with u an entity type—that is, it says whether u is a class, datatype, object property, data property, annotation property, or an individual. For example, the existence of the classes Plant and Animal (see axioms (6)–(7)) can be stated in the following way: Declaration(Class(Plant)) (34) 13 Declaration(Class(Animal)) (35) Declarations are nonlogical statements in the sense that they do not directly affect the semantics; they affect the semantics only indirectly by properly typing the ontology’s vocabulary. Certain declarations are required for an ontology to be syntactically valid. For example, if an ontology contains an axiom SubPropertyOf(P Q), (36) then P and Q must be declared; otherwise, it would not be possible to tell whether they are object or data properties. In OWL 2, however, a URI u can be used as an individual in O even if it is not declared as an individual in O. 
