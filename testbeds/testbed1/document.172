Assignment_(computer_science)
In , an '''assignment statement''' sets and/or re-sets the  stored in the storage location(s) denoted by a  ; in other words, it copies a value into the variable. In most  s, the assignment statement (or expression) is a fundamental construct.
Today, the most commonly used notation for this basic operation has come to be ''x'' = ''expr'' (originally  194951, popularized by  1957 and ) followed by ''x'' := ''expr'' (originally  1958, popularised by ), although there are many other notations in use. In some languages the symbol used is regarded as an  (meaning that the assignment has a value) while others define the assignment as a statement (meaning that it cannot be used in an expression).
Assignments typically allow a variable to hold different values at different times during its life-span and . However, some languages (primarily strictly functional) do not allow that kind of "destructive" reassignment, as it might imply changes of non-local state. The purpose is to enforce , i.e. functions that do not depend on the state of some variable(s), but produce the same results for a given set of parametric inputs at any point in time. Modern programs in other languages also often use similar strategies, although less strict, and only in certain parts, in order to reduce complexity, normally in conjunction with complementing methodologies such as ,  and .
==Semantics==
An assignment operation is a process in  in which different values are associated with a particular variable name as time passes. The program, in such model, operates by changing its state using successive assignment statements. Primitives of imperative programming languages rely on assignment to do . At the lowest level, assignment is implemented using  such as MOVE or STORE., by Bruce Tate
 are containers for values. It is possible to put a value into a variable and later replace it with a new one. An assignment operation modifies the current state of the executing program. Consequently, assignment is dependent on the concept of . In an assignment:
* The ''expression'' is evaluated in the current state of the program.
* The ''variable'' is assigned the computed value, replacing the prior value of that variable.
Example: Assuming that a is a numeric variable, the assignment a := 2*a means that the content of the variable a is doubled after the execution of the statement.
An example segment of  code:
int x = 10; 
float y;
x = 23;
y = 32.4f;
In this sample, the variable x is first declared as an int, and is then assigned the value of 10.  Notice that the declaration and assignment occur in the same statement. In the second line, y is declared without an assignment.  In the third line, x is reassigned the value of 23. Finally, y is assigned the value of 32.4.
For an assignment operation, it is necessary that the value of the ''expression'' is well-defined (it is a valid ) and that the ''variable'' represents a modifiable entity (it is a valid modifiable (non-) ). In some languages, typically  ones, it is not necessary to declare a variable prior to assigning it a value.
==Single assignment==
Any assignment that changes an existing value (e.g. x := x + 1) is disallowed in  languages. In , assignment is discouraged in favor of single assignment, also called ''initialization''. Single assignment is an example of  and differs from assignment as described in this article in that it can only be done once, usually when the variable is created; no subsequent reassignment is allowed.
An evaluation of expression does not have a  if it does not change an observable state of the machine, and produces same values for same input. Imperative assignment can introduce side effects while destroying and making the old value unavailable while substituting it with a new one, and is referred to as ''destructive assignment'' for that reason in  and , similar to .
Single assignment is the only form of assignment available in  languages, such as Haskell, which do not have variables in the sense of imperative programming languages but rather named constant values possibly of compound nature with their elements progressively defined ''on-demand''. Purely functional languages can provide an opportunity for , avoiding the  of sequential one step at time execution, since values are independent of each other.
Impure functional languages provide both single assignment as well as true assignment (though true assignment is typically used with less frequency than in imperative programming languages). For example, in Scheme, both single assignment (with let) and true assignment (with set!) can be used on all variables, and specialized primitives are provided for destructive update inside lists, vectors, strings, etc. In OCaml, only single assignment is allowed for variables, via the let ''name'' = ''value'' syntax; however destructive update can be used on elements of arrays and strings with separate