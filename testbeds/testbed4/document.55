But in certain cases the mode does interact depending upon the situation. So one must have an idea what mode interacts with the other and what mode does not interact. You can almost visualize that. Those with computer science background must, I can speak to them here, and you can visualize OpenGL almost as a state machine where you move on to a certain state and the state remains still you change that state.
Now, let us look at a color. If you set a color default to your background, foreground could be red, blue, green and magenta whatever it is, we talked of these 8 fundamental colors with 3 bits or 256 possible colors with 8 bit and so on. You remember, the concept of look-up-table when we discussed about graphics display. So you can set a particular color. And when you set a particular color and keep drawing primitives such as points, lines, vertices, poly lines.
Remember, these are the primitives, very low level primitives, you can of course use an object oriented approach and encapsulate and draw high level primitives which will over ride on the set of low level primitives provided by OpenGL and all that is possible. But when you are into a mode with a certain color, all those primitives will be drawn with that particular color unless you change that mode.
Unless you change that mode and move to another color, let us say in this case I am talking of color as an example of a mode but it could be something else as well. When you set a particular color that mode is particular and is set for all primitives run after that till you change the color then you have basically gone on to a different mode.
So, we will look at these features, we will continue with the discussion 3D transformations, color then lighting which provide facilities for flat shading, Gouraud shading, Phong shading etc. And it also provides rendering in terms of texture mapping which is a unique feature in OpenGL where you can map on to a texture on to a particular surface. And of course modeling, here we are talking about primitives to be defined as a group of one or more vertices.
We talked of primitives as points, vertices, lines, you can have primitives as curves. A vertex could be defined as a point or the end point of a line or a corner or a polygon and things like that. A primitive could be a curvature. And when you look at this particular curve which we called as nurbs is a very new term which I am introducing here with respect to OpenGL. This concept of nurbs is available in high level toolkits such as maya. I gave this example of the software maya in the introduction of the lecture which is used for making movies.
Good animation high quality virtual reality movies are made of maya and maya provides you to create complex objects not only with points, lines, polygons but it also provides you nurbs.
What is nurbs? It is a non uniform rational B spline. I repeat, remember, you can note down this term non uniform rational B spline. We talked about cubic spline and Bezier curves, a combination of that whereas a spline uses the Bernstein basis called a B spline. So we have this nurbs has curves and surfaces and that could be also used to define your primitives. And the data which it could consist of vertices, colors, surface normal, texture coordinate, edge flags, which could be associated with either a vertex or a particular curve or a primitive in its associated data they are processed independently and they are processed in the graphics pipeline.
The graphics pipeline will process all the attributes necessary for the particular primitive. And I have used the word primitive earlier in the lecture series and I use it again here in OpenGL. the word primitive does exist and I repeat the primitive could be a single point, it could be a single line, it could be a group of lines, it could be a polygon, it could be a shaded polygon or a poly line, it could be a nurb, it could be a simple triangle, it could be a surface and there are various attributes associated with these primitives.
Of course the first fundamental descriptors you need for defining primitives at their x y z coordinates is one point or multiple points. Then depending upon the type of a primitive you could have its surface normal, you could have its color, you could have its texture, you could have other properties. We will see later on like the material properties of a surface which could be used for rendering and shading. So, all these are very important
properties which are associated with lightning and shading which we discussed also in the Phong model and the Gouraud model also. Those are important features which must be incorporated as attributes of your primitives.
And their exist an OpenGL graphics pipeline which will process this data, data means a stream of such request to process these set of vertices in a certain sequence, not randomly of course, is when a sequence of events starts in OpenGL.
When a sequence opens, events start it is an execution model which takes over and it starts interpreting your OpenGL code and it could move from one mode to another and then it starts processing the sequence of vertices the way in which your program is written. So we are talking of features of openGL which work on a set of primitives defined by your program and these are the features. We talked about 3D transformations. If you read through the slide, color models, lightning you can define more than one light source, you can have various types of lightning properties, and you can define a light based on a certain color. And the surface material also can have a certain color we already discussed about this where the light color could be different than the color of the surface material. And of course they could interact to give you different phenomena.
The lightning involves various other properties like it can also talk about the effect of attenuations, the atmospheric attenuation of what is called as the term used in OpenGL called fog, the effect of fog.
We talked of this alpha as a color parameter. If you look back into the slide in terms of this color parameter RGB which is addition and known to you as the three components of a color in a cube you have this parameter called alpha which is used for blending which tells you how much transparent an object is, is it opaque or is it transparent, is it transluscent or semi transparent or not. So OpenGL will tell you or gives you the option of providing whether the surface which you are drawing is completely opaque are not, completely transluscent or it is somewhere in between. So that is the alpha factor which you provide in a scale from 0 to 1 normalized. Of course you might have to give a value from 0 to 55 and tell you what is the blending alpha factor for a particular object surface or even at a high level however called any primitive may have its corresponding color not only in terms of RGB but also alpha.
The color of the light may not have an alpha factor, it will only have an RGB but the material may have or primitives will have an alpha factor. So coming to the last part of the features in OpenGL we talked of this atmospheric fog alpha blending corresponding to this alpha and you can have effects such as even motion blur. That will be very interesting, it will have concepts such as even motion blur. So these are the certain features which we had seen in OpenGL and based on these features we can start to discuss about the OpenGL graphics pipeline.
Finally let us read through these features again, 3D transformations, color models, lighting, rendering, modeling and other miscellaneous effects such as atmospheric fog, alpha blending and motion blur.