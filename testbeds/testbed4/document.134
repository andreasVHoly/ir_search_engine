CMSC 427 Computer Graphics1
David M. Mount Department of Computer Science University of Maryland Spring 2004

Lecture 4: Drawing in OpenGL: Drawing and Viewports
Reading: Chapters 2 and 3 in Hearn and Baker.
Basic Drawing: We have shown how to create a window, how to get user input, but we have not discussed how to get graphics to appear in the window. Today we discuss OpenGL's capabilities for drawing objects.
Before being able to draw a scene, OpenGL needs to know the following information: what are the objects to be drawn, how is the image to be projected onto the window, and how lighting and shading are to be performed.
Lecture Notes 13 CMSC 427
To begin with, we will consider a very the simple case. There are only 2-dimensional objects, no lighting or shading. Also we will consider only relatively little user interaction.
Because we generally do not have complete control over the window size, it is a good idea to think in terms of drawing on a rectangular idealized drawing region, whose size and shape are completely under our control. Then we will scale this region to ?t within the actual graphics window on the display. More generally, OpenGL allows for the grahics window to be broken up into smaller rectangular subwindows, called viewports. We will then have OpenGL scale the image drawn in the idealized drawing region to ?t within the viewport. The main advantage of this approach is that it is very easy to deal with changes in the window size.
We will consider a simple drawing routine for the picture shown in the ?gure. We assume that our idealized drawing region is a unit square over the real interval [0,1]×[0,1]. (Throughout the course we will use the notation [a,b] to denote the interval of real values z such that a = z = b. Hence, [0,1]×[0,1] is a unit square whose lower left corner is the origin.) This is illustrated in Fig. 9.
0.5
1
10.50
red
blue
0
Fig. 9: Drawing produced by the simple display function.
Glut uses the convention that the origin is in the upper left corner and coordinates are given as integers. This makes sense for Glut, because its principal job is to communicate with the window system, and most window systems (X-windows, for example) use this convention. On the other hand, OpenGL uses the convention that coordinates are (generally) ?oating point values and the origin is in the lower left corner. Recalling the OpenGL goal is to provide us with an idealized drawing surface, this convention is mathematically more elegant.
The Display Callback: Recall that the display callback function is the function that is called whenever it is necessary to redraw the image, which arises for example: • The initial creation of the window, • Whenever the window is uncovered by the removal of some overlapping window, • Whenever your program requests that it be redrawn (through the use of glutPostRedisplay() function, as in the case of an animation, where this would happen continuously.
The display callback function for our program is shown below. We ?rst erase the contents of the image window, then do our drawing, and ?nally swap buffers so that what we have drawn becomes visible. (Recall double buffering from the previous lecture.) This function ?rst draws a red diamond and then (on top of this) it draws a blue rectangle. Let us assume double buffering is being performed, and so the last thing to do is invoke glutSwapBuffers() to make everything visible.
Let us present the code, and we will discuss the various elements of the solution in greater detail below.
Clearing the Window: The command glClear() clears the window, by overwriting it with the background color. This is set by the call
glClearColor(GL?oat Red, GL?oat Green, GL?oat Blue, GL?oat Alpha).
Lecture Notes 14 CMSC 427
Sample Display Function void myDisplay() // display function { glClear(GL_COLOR_BUFFER_BIT); // clear the window
glColor3f(1.0, 0.0, 0.0); // set color to red glBegin(GL_POLYGON); // draw a diamond glVertex2f(0.90, 0.50); glVertex2f(0.50, 0.90); glVertex2f(0.10, 0.50); glVertex2f(0.50, 0.10); glEnd();
glColor3f(0.0, 0.0, 1.0); // set color to blue glRectf(0.25, 0.25, 0.75, 0.75); // draw a rectangle
glutSwapBuffers(); // swap buffers
}
The type GL?oat is OpenGL's rede?nition of the standard ?oat. To be correct, you should use the approved OpenGL types (e.g. GL?oat, GLdouble, GLint) rather than the obvious counterparts (?oat, double, and int). Typically the GL types are the same as the corresponding native types, but not always.
Colors components are given as ?oats in the range from 0 to 1, from dark to light. Recall from Lecture 2 that the A (or a) value is used to control transparency. For opaque colors A is set to 1. Thus to set the background color to black, we would use glClearColor(0.0, 0.0, 0.0, 1.0), and to set it to blue use glClearColor(0.0, 0.0, 1.0, 1.0). (Hint: When debugging your program, it is often a good idea to use an uncommon background color, like a random shade of pink, since black can arise as the result of many different bugs.) Since the background color is usually independent of drawing, the function glClearColor() is typically set in one of your initialization procedures, rather than in the drawing callback function.
Clearing the window involves resetting information within the frame buffer. As we mentioned before, the frame buffer may store different types of information. This includes color information, of course, but depth or distance information is used for hidden surface removal. Typically when the window is cleared, we want to clear everything, but occasionally it is possible to achieve special effects by erasing only part of the buffer (just the colors or just the depth values). So the glClear() command allows the user to select what is to be cleared. In this case we only have color in the depth buffer, which is selected by the option GL COLOR BUFFER BIT. If we had a depth buffer to be cleared it as well we could do this by combining these using a "bitwise or" operation:
glClear(GL COLOR BUFFER BIT - GL DEPTH BUFFER BIT)
Drawing Attributes: The OpenGL drawing commands describe the geometry of the object that you want to draw. More speci?cally, all OpenGL is based on drawing objects with straight sides, so it suf?ces to specify the vertices of the object to be drawn. The manner in which the object is displayed is determined by various drawing attributes (color, point size, line width, etc.).
The command glColor3f() sets the drawing color. The arguments are three GL?oat's, giving the R, G, and B components of the color. In this case, RGB = (1 ,0 ,0) means pure red. Once set, the attribute applies to all subsequently de?ned objects, until it is set to some other value. Thus, we could set the color, draw three polygons with the color, then change it, and draw ?ve polygons with the new color.
This call illustrates a common feature of many OpenGL commands, namely ?exibility in argument types. The suf?x "3f" means that three ?oating point arguments (actually GL?oat's) will be given. For example, glColor3d() takes three double (or GLdouble) arguments, glColor3ui() takes three unsigned int arguments, and so on. For
Lecture Notes 15 CMSC 427
?oats and doubles, the arguments range from 0 (no intensity) to 1 (full intensity). For integer types (byte, short, int, long) the input is assumed to be in the range from 0 (no intensity) to its maximum possible positive value (full intensity).
But that is not all! The three argument versions assume RGB color. If we were using RGBA color instead, we would use glColor4d() variant instead. Here "4" signi?es four arguments. (Recall that the A or alpha value is used for various effects, such an transparency. For standard (opaque) color we set A =1.0.)
In some cases it is more convenient to store your colors in an array with three elements. The suf?x "v" means that the argument is a vector. For example glColor3dv() expects a single argument, a vector containing three GLdouble's. (Note that this is a standard C/C++ style array, not the class vector from the C++ Standard Template Library.) Using C's convention that a vector is represented as a pointer to its ?rst element, the corresponding argument type would be "const GLdouble*".
Whenever you look up the prototypes for OpenGL commands, you often see a long list, some of which are shown below.
void glColor3d(GLdouble red, GLdouble green, GLdouble blue) void glColor3f(GLfloat red, GLfloat green, GLfloat blue) void glColor3i(GLint red, GLint green, GLint blue) ... (and forms for byte, short, unsigned byte and unsigned short) ...
void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) ... (and 4-argument forms for all the other types) ...
void glColor3dv(const GLdouble *v) ... (and other 3- and 4-argument forms for all the other types) ...
Drawing commands: OpenGL supports drawing of a number of different types of objects. The simplest is glRectf(), which draws a ?lled rectangle. All the others are complex objects consisting of a (generally) unpredictable number of elements. This is handled in OpenGL by the constructs glBegin( mode ) and glEnd(). Between these two commands a list of vertices is given, which de?nes the object. The sort of object to be de?ned is determined by the mode argument of the glBegin() command. Some of the possible modes are illustrated in Fig. 10. For details on the semantics of the drawing methods, see the reference manuals.
Note that in the case of GL POLYGON only convex polygons (internal angles less than 180 degrees) are supported. You must subdivide nonconvex polygons into convex pieces, and draw each convex piece separately.
glBegin(mode); glVertex(v0); glVertex(v1); ... glEnd();
In the example above we only de?ned the x- and y-coordinates of the vertices. How does OpenGL know whether our object is 2-dimensional or 3-dimensional? The answer is that it does not know. OpenGL represents all vertices as 3-dimensional coordinates internally. This may seem wasteful, but remember that OpenGL is designed primarily for 3-d graphics. If you do not specify the z-coordinate, then it simply sets the z-coordinate to 0.0. By the way, glRectf() always draws its rectangle on the z =0plane.
Between any glBegin()...glEnd() pair, there is a restricted set of OpenGL commands that may be given. This includes glVertex() and also other command attribute commands, such as glColor3f(). At ?rst it may seem a bit strange that you can assign different colors to the different vertices of an object, but this is a very useful feature. Depending on the shading model, it allows you to produce shapes whose color blends smoothly from one end to the other.
There are a number of drawing attributes other than color. For example, for points it is possible adjust their size (with glPointSize()). For lines, it is possible to adjust their width (with glLineWidth()), and create dashed.
