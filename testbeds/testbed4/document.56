It can provide viewing, clipping and texture, it can also provide a hidden surface removal. These are some of the feature in a graphics library. It provides you primitives to draw points, lines and polygons, it can provide concepts of shading and color. It can provide you options of matrix based transformations 2D and 3D which we have seen earlier. It can provide view clipping and texture, it can provide hidden surface removal. These are the low level facilities available in OpenGL, minimum for any OpenGL libraries.
Let us look into the GLU Graphics Library Utilities. It provides you high level viewing such as perspective and orthographic projection. It provides you image scaling, polygon tessellation, it provides higher level structures such as spheres, cylinders and quadratic surfaces. This will be very handy.
We have discussed about wireframe diagrams, sweep representations to generate certain primitive structures such as spheres, cones, cylinders or even surfaces with the help of curves. We discussed about parametric surface and all that. Now GLU provides you these as direct primitives. It is a big advantage that you do not need to spend time and write your own program and the program may not need time to generate these. So now you can treat these spheres, cylinders as an example and quadratic surfaces as primitives. And you do not need to worry about where those x y z are and how many precision you need to give, but that of course you have to decide.
But you did not to know to come up with the sweep representation to generate your x y z vertices for your sphere. So that is what GLU provides. GLUT is basically a windowing toolkit for interfaces for keyboard, mouse handler and other windows events. So GLUT is basically an interface to windows. And of course there is a whole lot of other operations with the GLU and GL did not provide, it is not in the list here. You must go to the OpenGL reference manual to come up with a list of such flexibilities which are provided.
If you look back I was just talking about translation, shading, color, primitives and all that and along with the operations to create vertices which may have certain flags, colors, matrix transformations, lighting and color. You can generate textures, you can generate various primitives, various types of clippings are possible, provisions are provided, transform to window coordinates, rasterizations, you can generate pixels, generate bit maps, texture memory and then of course you have the concepts of fragments.
We will discuss about the concept of Phong, about atmospheric attenuation, about the concept of test which are done on fragments such as seizer test, alpha test, stencil test, death buffer test, blending, dithering, logical operations on pixels, copying pixels operations, frame buffer operations on pixels and so on and so forth. These are various types of operations which are possible in the OpenGL and GLU. Now it is not possible in a short frame of time to discuss each of these commands because this is not a lecture series only on OpenGL. This is just to kick start you on OpenGL so that you get excited and will start to use it. Of course you see some examples about this programs really working on my system you will really get excited and will be able to see how it works. So coming back to abstractions we have this windowish toolkit of GL, GLU and GLUT.
(Refer Slide Time: 00:51:18)
Well, we talked of a 3D viewing pipeline which is also present in your OpenGL environment where we have a 3D viewing pipeline which starts with object coordinates transformed by the modelview matrix to the world coordinates.
And the modelview matrix V into M which you can set will transform this object coordinates to world coordinates then the projection matrix will transform the world coordinates on to clip coordinates.
Then you can have a clipping stage which will take the input of this clip coordinates and generate and pass it on to the perspective division matrix and that will generate the normalized device coordinates.
We discussed about this canonical view normalized device coordinates earlier and then of course we have the viewport matrix which will generate the window coordinates in output or written on to the device port.
I must inform you that this flow chart is taken from the book by F. S. Hill Junior which is computer graphics using OpenGL, computer graphics using OpenGL by F. S. Hill. I will give you a detailed list of references later on in the next class after I finish the coverage of OpenGL. But this 3D viewing pipeline is different from the OpenGL pipeline